#!/usr/bin/env python

"""\
$LicenseInfo:firstyear=2006&license=viewerlgpl$
Second Life Viewer Source Code
Copyright (C) 2006-2014, Linden Research, Inc.

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation;
version 2.1 of the License only.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA

Linden Research, Inc., 945 Battery Street, San Francisco, CA  94111  USA
$/LicenseInfo$
"""

"""
@file   SL_Launcher
@author coyot
@date   2016-06-23
"""

import os
import os.path
import platform
import subprocess
import sys
import logging
from vmp_util import SL_Logging, Application, BuildData
from InstallerUserMessage import status_message

#if for some reason we are running on a POSIX machine with python less than 2.7
#just give up on VMP and execute the viewer per product.
if os.name != 'nt' and platform.python_version() < '2.7':
    log = SL_Logging.getLogger('SL_Launcher')
    log.error("Computer is below minimum specifications. Python version needs to be 2.7, but is %r" % platform.python_version())
    if sys.platform.startswith('darwin'):
        executable_name = "Second Life"
    elif sys.platform.startswith("linux"):
        executable_name = "secondlife"
    viewer_binary = os.path.join(os.path.dirname(os.path.abspath(sys.argv[0])), executable_name) 
    log.debug("viewer binary name: %r" % viewer_binary)

    parser = argparse.ArgumentParser()
    args, args_list_to_pass = parser.parse_known_args()

    command = list(args_list_to_pass)
    command.insert(0,viewer_binary)
    #note that we are now using the 2.6 version of subprocess 
    log.warning("Attempting to launch viewer without update check: %r" % command)
    viewer_process = subprocess.Popen(command)
    sys.exit(0)

import argparse
import cgitb
import collections
#NOTA BENE: 
#   For POSIX platforms, llsd.py will be imported from the same directory.  
#   For Windows, llsd.py will be compiled into the executable by pyinstaller
try:
    from llbase import llsd
except:
    #if Windows, this is expected, if not, we're dead
    if os.name == 'nt':
        pass
import Tkinter
import ttk

from datetime import datetime

#module globals

#this is mostly for testing on Windows, emulating exe enviroment with $python scriptname
if 'ython' in sys.executable:
    sys.executable =  os.path.abspath(sys.argv[0])
cwd = os.path.dirname(os.path.realpath(str(sys.executable)))

#make sure we find our local llbase
sys.path.insert(0, os.path.join(cwd, 'llbase'))

#imports of other VMP modules
import InstallerUserMessage
import update_manager

#this is to support pyinstaller, which uses sys._MEIPASS to point to the location
#the bootloader unpacked the bundle to.  If the getattr returns false, we are in a 
#normal Python environment.
if getattr(sys, 'frozen', False):
    __file__ = sys._MEIPASS

def get_cmd_line(cmd_settings_file = None):
    log=SL_Logging.getLogger('get_cmd_line')
    if cmd_settings_file is None:
        platform_name = platform.system()
    #find the parent of the logs and user_settings directories
        if (platform_name == 'Darwin'):
            cmd_settings_file = os.path.join(os.path.dirname(os.path.dirname(os.path.realpath(__file__))), 'Resources/app_settings/cmd_line.xml')
        elif (platform_name == 'Linux'): 
            cmd_settings_file = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'app_settings/cmd_line.xml')
    #using list format of join is important here because the Windows pathsep in a string escapes the next char
        elif (platform_name == 'Windows'):
            cmd_settings_file = os.path.join(os.path.dirname(os.path.realpath(sys.executable)), 'app_settings', 'cmd_line.xml')
        else:
            cmd_settings_file = None

    try:
        cmd_line = llsd.parse((open(cmd_settings_file)).read())
    except:
        log.warning("Could not parse settings file %s" % cmd_settings_file)
        cmd_line = None

    return cmd_line

def capture_vmp_args(arg_list = None, cmd_line = None):
    #expected input format: arg_list = ['--set', 'foo', 'bar', '-X', '-Y', 'qux']
    #take a copy of the viewer parameters that are of interest to VMP.
    #the regex for a parameter is --<param> {opt1} {opt2}
    log=SL_Logging.getLogger('capture_vmp_args')
    cli_overrides = {}   
    if not cmd_line:
        cmd_line = get_cmd_line()

    vmp_params = {'--channel':'channel', '--settings':'settings', '--set':'set', '--ForceAddressSize':'forceaddresssize'}
    #the settings set with --set.  All such settings have only one argument.
    vmp_setters = ('UpdaterMaximumBandwidth', 'UpdaterServiceSetting', 'UpdaterServiceURL', 'UpdaterWillingToTest')   

    #Here turn the list into a queue, popping off the left as we go. Note that deque() makes a copy by value, not by reference
    #Because of the complexity introduced by the uncertainty of how many options a parameter can take, this is far less complicated code than the more
    #pythonic (x,y) = <some generator> since we will sometimes have (x), sometimes (x,y) and sometimes (x,y,z)
    #also, because the pop is destructive, we prevent ourselves from iterating back over list elements that iterator methods would peek ahead at
    if arg_list is not None:
        log.info("Parsing passed arguments: %r" % arg_list)
        vmp_queue = collections.deque(arg_list)
        cli_overrides[vmp_params['--set']] = {}
        while (len(vmp_queue)):
            param = vmp_queue.popleft()
            #if it is not one of ours, pop through args until we get to the next parameter
            if param in vmp_params.keys():
                if param == '--set':
                    setting_name = vmp_queue.popleft()
                    setting_value = vmp_queue.popleft()
                    if setting_name in vmp_setters:
                        cli_overrides[vmp_params[param]].update({setting_name:setting_value})
                else:
                    #find out how many args this parameter has
                    no_dashes = vmp_params[param]
                    #special case for ForceAddressSize, since it is not in cmd_line.xml
                    if param != "--ForceAddressSize":
                        count = cmd_line[no_dashes]['count']
                        param_args = []
                        if count > 1:
                            for argh in range(0,count):
                                param_args.append(vmp_queue.popleft())
                        elif count == 1:
                            param_args = vmp_queue.popleft()
                    else:  
                        if no_dashes == 'forceaddresssize':
                            #guard against missing argument
                            try:
                                #peek ahead at the head of the queue, it could be a legit arg, an empty deque or some other param starting
                                if vmp_queue[0] in ['32', '64']:
                                    param_args = vmp_queue.popleft()
                            except IndexError, ie:
                                log.info('ForceAddressSize passed without a parameter, ignoring')
                                log.debug('Exception: %r' % ie)
                                #set to default
                                param_args = '32'
                    
                    #the parameter name is the key, the (possibly empty) list of args is the value
                    cli_overrides[vmp_params[param]] = param_args

    #to prevent KeyErrors on missing keys, set the remainder to None
    try:
        cli_overrides['set']
    except KeyError:
        cli_overrides['set'] = {}
    for key in vmp_params:
        if key != '--set':
            try:
                cli_overrides[vmp_params[key]]
            except KeyError:
                cli_overrides[vmp_params[key]] = None
        else:
            for arg in vmp_setters:
                try:
                    cli_overrides[vmp_params[key]][arg]
                except KeyError:
                    cli_overrides[vmp_params[key]][arg] = None
    return cli_overrides

def main():
    #main entry point      
    parser = argparse.ArgumentParser()
    args, args_list_to_pass = parser.parse_known_args()

    version=BuildData.get('Version')
    address_size=BuildData.get('Address Size')
    log.info("Viewer version %s (%d bit)" % (version, address_size))

    executable_name = Application.name()

    #find the viewer to be lauched
    viewer_binary = os.path.join(os.path.dirname(os.path.abspath(sys.argv[0])), executable_name) 

    log.debug("viewer binary name: %r" % viewer_binary)

    #defaults to make sure the right thing happens if called with no args
    args = ""
    vmp_args = capture_vmp_args(args_list_to_pass)
    log.debug("Captured VMP args: %r" % vmp_args)
    #make a copy by value, not by reference
    command = list(args_list_to_pass)
       
    #consume ForceAddressSize since the viewer doesn't know about it.  Guard against no argument provided.
    try:
        param_index_to_remove = command.index('--ForceAddressSize')
    except ValueError:
        #failed to remove something that wasn't there, shrug and keep going
        pass   
    else:
        # remove both the switch and its argument
        del command[param_index_to_remove:param_index_to_remove+2]

    log.debug("Calling update manager with %r" % vmp_args)
    try:
        # update_manager() returns the viewer to launch, or None if no launch
        # is desired -- or raises UpdateError.
        new_viewer = update_manager.update_manager(viewer_binary, vmp_args)
    except update_manager.UpdateError as err:
        log.error("Update manager raised %r" % err)
        # use status_message() so the frame will persist until this process
        # terminates
        status_message('%s\nViewer will launch momentarily.' % err)
        new_viewer = viewer_binary

    # Clear any existing status message: we're about to launch the viewer.
    status_message(None)

    if (viewer_binary != new_viewer):
        launch_as_replacement(new_viewer) # forget arguments since they don't apply to installers
        # does not return
 
    viewer_process = launch_as_child(viewer_binary, command)
    # at the moment, we just wait here.  Later, the crash monitor will be launched at this point
    rc = viewer_process.wait()
    log.info("Viewer terminated with %s" % rc)
    log.info("Launcher exiting after viewer exit.")

def launch_as_child(viewer, command_args):
    """
    Launch the passed 'viewer' with arguments as specified by 'command'. 

    If the launch attempt fails, squawk in various ways (log, stderr, popup)
    and terminate.

    If it succeeds, return the subprocess.Popen object.
    """
    log.info("Launching current viewer '%s' '%s'" % (viewer, "' '".join(command_args)))
    command = [viewer] + command_args

    env = os.environ.copy()
    env["PARENT"] = "SL_Launcher" # suppresses warning about not running the viewer directly

    try:
        viewer_process = subprocess.Popen(command, env=env)
    except Exception as e:
        log.error("Failed to launch %s. Error messages as follows:\n%r" % (viewer, e))
        message = "Failed to launch %s, see log for details" % viewer
        frame = InstallerUserMessage.InstallerUserMessage(
            title="SL_Launcher",
            text=message,
            icon_name="head-sl-logo.gif",
            )
        frame.basic_message(message=message)
        sys.exit(-1)

    log.info("Successfully launched %s" % command)
    return viewer_process

def launch_as_replacement(next_executable):
    """
    Run next_executable as a replacement for the current process.
    Depending on the platform, the executable may be an installer or the next viewer.
    """
    exec_args=[]
    if sys.platform.startswith('darwin'):
        executable = '/usr/bin/open' # we can't just exec the .app
        exec_args.insert(0, next_executable)

    elif sys.platform.startswith('win') or sys.platform == 'cygwin':
        executable = next_executable

    else:
        executable = next_executable

    exec_args.insert(0, os.path.basename(executable))

    log.info("Executing %s as '%s'" % (executable, "' '".join(exec_args)))
    
    # ensure that logs are closed and flushed before execing
    logging.shutdown()
    try:
        os.execv(executable, exec_args)
        # if that worked, we're gone...

    except Exception as err:
        # logging is gone, can't do that, so put up a dialog
        message = "Launch failed\n%s" % err
        frame = InstallerUserMessage.InstallerUserMessage(
            title="SL_Launcher",
            text=message,
            icon_name="head-sl-logo.gif",
            )
        frame.basic_message(message=message)
        sys.exit(-1)
    # process has been replaced or killed - does not return

if __name__ == "__main__":
    # Initialize the python logging system to SL Logging format and destination
    cgitb.enable(format='text')
    log = SL_Logging.getLogger('SL_Launcher')
    try:
        main()
    except Exception:
        log_traceback = cgitb.Hook(file=SL_Logging.stream(prefix_msg="Unhandled exception:"), format='text')
        log_traceback.handle()


    
