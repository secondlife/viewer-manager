#!/usr/bin/env python

"""\
$LicenseInfo:firstyear=2006&license=viewerlgpl$
Second Life Viewer Source Code
Copyright (C) 2006-2014, Linden Research, Inc.

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation;
version 2.1 of the License only.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA

Linden Research, Inc., 945 Battery Street, San Francisco, CA  94111  USA
$/LicenseInfo$
"""

"""
@file   SL_Launcher
@author coyot
@date   2016-06-23
"""

import os
import os.path
import platform
import subprocess
import sys
import logging
from vmp_util import SL_Logging, Application, BuildData
from InstallerUserMessage import status_message

#if for some reason we are running on a POSIX machine with python less than 2.7
#just give up on VMP and execute the viewer per product.
if os.name != 'nt' and platform.python_version() < '2.7':
    log = SL_Logging.getLogger('SL_Launcher')
    log.error("Computer is below minimum specifications. Python version needs to be 2.7, but is %r" % platform.python_version())
    if sys.platform.startswith('darwin'):
        executable_name = "Second Life"
    elif sys.platform.startswith("linux"):
        executable_name = "secondlife"
    viewer_binary = os.path.join(os.path.dirname(os.path.abspath(sys.argv[0])), executable_name) 
    log.debug("viewer binary name: %r" % viewer_binary)

    parser = argparse.ArgumentParser()
    args, args_list_to_pass = parser.parse_known_args()

    command = list(args_list_to_pass)
    command.insert(0,viewer_binary)
    #note that we are now using the 2.6 version of subprocess 
    log.warning("Attempting to launch viewer without update check: %r" % command)
    viewer_process = subprocess.Popen(command)
    sys.exit(0)

import argparse
import cgitb
import collections
#NOTA BENE: 
#   For POSIX platforms, llsd.py will be imported from the same directory.  
#   For Windows, llsd.py will be compiled into the executable by pyinstaller
try:
    from llbase import llsd
except:
    #if Windows, this is expected, if not, we're dead
    if os.name == 'nt':
        pass
import Tkinter
import ttk

from datetime import datetime

#module globals

#this is mostly for testing on Windows, emulating exe enviroment with $python scriptname
if 'ython' in sys.executable:
    sys.executable =  os.path.abspath(sys.argv[0])
cwd = os.path.dirname(os.path.realpath(str(sys.executable)))

#make sure we find our local llbase
sys.path.insert(0, os.path.join(cwd, 'llbase'))

#imports of other VMP modules
import InstallerUserMessage
import update_manager

#this is to support pyinstaller, which uses sys._MEIPASS to point to the location
#the bootloader unpacked the bundle to.  If the getattr returns false, we are in a 
#normal Python environment.
if getattr(sys, 'frozen', False):
    __file__ = sys._MEIPASS

def get_cmd_line(cmd_settings_file = None):
    log=SL_Logging.getLogger('get_cmd_line')
    if cmd_settings_file is None:
        platform_name = platform.system()
        #find the parent of the logs and user_settings directories
        if (platform_name == 'Darwin'):
            # Contents/MacOS/__file__ => Contents/Resources
            cmd_settings_file = os.path.join(os.path.dirname(__file__), os.pardir, 'Resources')
        elif (platform_name == 'Linux'):
            # app_settings in same directory as __file__
            cmd_settings_file = os.path.dirname(__file__)
        elif (platform_name == 'Windows'):
            # app_settings in same directory as this executable
            cmd_settings_file = os.path.dirname(sys.executable)
        else:
            # unsupported platform
            cmd_settings_file = os.path.dirname(__file__)
            log.warning("Unsupported platform %s, guessing app_settings in %s",
                        platform_name, cmd_settings.file)

        # now that we've got the platform-dependent part...
        cmd_settings_file = os.path.join(cmd_settings_file, 'app_settings', 'cmd_line.xml')

    log.debug("reading command line rules from '%s'" % cmd_settings_file)
    try:
        cmd_line = llsd.parse(open(cmd_settings_file).read())
    except (IOError, OSError, llsd.LLSDParseError) as err:
        log.warning("Could not parse settings file %r: %r", cmd_settings_file, err)
        cmd_line = {}

    return cmd_line

def capture_vmp_args(arg_list = None, cmd_line = None):
    # expected input format: arg_list = ['--set', 'foo', 'bar', '-X', '-Y', 'qux']
    # take a copy of the viewer parameters that are of interest to VMP.
    # the regex for a parameter is --<param> {opt1} {opt2}
    log=SL_Logging.getLogger('capture_vmp_args')
    cli_overrides = {}   
    if cmd_line is None:
        cmd_line = get_cmd_line()

    vmp_params = {'--channel':'channel', '--settings':'settings', '--set':'set'}
    # the settings set with --set.  All such settings have only one argument.
    vmp_setters = ('UpdaterMaximumBandwidth', 'UpdaterServiceSetting', 'UpdaterServiceURL', 'UpdaterWillingToTest', 'ForceAddressSize')   

    # Here turn the list into a queue, popping off the left as we go. Note that deque() makes a copy by value, not by reference
    # Because of the complexity introduced by the uncertainty of how many options a parameter can take, this is far less complicated code than the more
    # pythonic (x,y) = <some generator> since we will sometimes have (x), sometimes (x,y) and sometimes (x,y,z)
    # also, because the pop is destructive, we prevent ourselves from iterating back over list elements that iterator methods would peek ahead at
    if arg_list is not None:
        log.info("Parsing passed arguments: %r" % arg_list)
        vmp_queue = collections.deque(arg_list)
        cli_overrides[vmp_params['--set']] = {}
        while vmp_queue:
            param = vmp_queue.popleft()
            #if it is not one of ours, pop through args until we get to the next parameter
            try:
                vmp_param = vmp_params[param]
            except KeyError:
                # param is not one we care about
                continue

            if param == '--set':
                setting_name = vmp_queue.popleft()
                setting_value = vmp_queue.popleft()
                if setting_name in vmp_setters:
                    cli_overrides[vmp_param][setting_name] = setting_value
            else:
                # just skip this one and keep looking for the next known option
                # yes, this will break if someone tries to pass one of our options
                # as the argument to some other option ... they deserve whatever they get
                try:
                    count = cmd_line[vmp_param]['count']
                except KeyError:
                    # cmd_line.xml has no entry for vmp_param, or entry has no
                    # count field
                    log.warning("Command line switch %r not defined in cmd_line.xml", param)
                    # pretend count is 0; don't eat any subsequent args
                    count = 0

                # pop as many additional args as indicated by count
                param_args = [vmp_queue.popleft() for argh in range(count)]
                if count == 1:
                    # in the special case of one arg, store scalar instead of list
                    param_args = param_args[0]

                #the parameter name is the key, the (possibly empty) list of args is the value
                cli_overrides[vmp_param] = param_args

    return cli_overrides

def main():
    #main entry point      
    parser = argparse.ArgumentParser()
    args, args_list_to_pass = parser.parse_known_args()

    version=BuildData.get('Version')
    address_size=int(BuildData.get('Address Size'))
    log.info("Viewer version %s (%d bit)" % (version, address_size))

    executable_name = Application.name()

    #find the viewer to be lauched
    viewer_binary = os.path.join(os.path.dirname(os.path.abspath(sys.argv[0])), executable_name) 

    log.debug("viewer binary name: %r" % viewer_binary)

    #defaults to make sure the right thing happens if called with no args
    args = ""
    vmp_args = capture_vmp_args(args_list_to_pass)
    log.debug("Captured VMP args: %r" % vmp_args)
    #make a copy by value, not by reference
    command = list(args_list_to_pass)
       
    try:
        # update_manager() returns the viewer to launch, or None if no launch
        # is desired -- or raises UpdateError.
        new_viewer = update_manager.update_manager(viewer_binary, vmp_args)
    except update_manager.UpdateError as err:
        log.error("Update manager raised %r" % err)
        # use status_message() so the frame will persist until this process
        # terminates
        status_message('%s\nViewer will launch momentarily.' % err)
        new_viewer = viewer_binary

    # Clear any existing status message: we're about to launch the viewer.
    status_message(None)

    if (viewer_binary != new_viewer):
        launch_as_replacement(new_viewer) # forget arguments since they don't apply to installers
        # does not return
 
    viewer_process = launch_as_child(viewer_binary, command)
    # at the moment, we just wait here.  Later, the crash monitor will be launched at this point
    rc = viewer_process.wait()
    log.info("Viewer terminated with %s" % rc)
    log.info("Launcher exiting after viewer exit.")

def launch_as_child(viewer, command_args):
    """
    Launch the passed 'viewer' with arguments as specified by 'command'. 

    If the launch attempt fails, squawk in various ways (log, stderr, popup)
    and terminate.

    If it succeeds, return the subprocess.Popen object.
    """
    if update_manager.onWindows10orHigher() \
      and int(BuildData.get('Address Size')) == 64 \
      and update_manager.Windows10Video.isUnsupported():
        command_args = command_args + ['--set', 'SkipBenchmark', '1']
        
    command = [viewer] + command_args
    log.info("Launching current viewer '%s' '%s'" % (viewer, "' '".join(command_args)))

    env = os.environ.copy()
    env["PARENT"] = "SL_Launcher" # suppresses warning about not running the viewer directly

    try:
        viewer_process = subprocess.Popen(command, env=env)
    except Exception as e:
        log.error("Failed to launch %s. Error messages as follows:\n%r" % (viewer, e))
        message = "Failed to launch %s, see log for details" % viewer
        InstallerUserMessage.basic_message(message)
        sys.exit(-1)

    log.info("Successfully launched %s" % command)
    return viewer_process

def launch_as_replacement(next_executable):
    """
    Run next_executable as a replacement for the current process.
    Depending on the platform, the executable may be an installer or the next viewer.
    """
    if sys.platform.startswith('win') or sys.platform == 'cygwin':
        # MAINT-7831: Windows doesn't have a native execv(), and it's not
        # clear that Python's os.execv() emulation is working for us. Use
        # subprocess.Popen in this scenario too.
        command = [next_executable]
        log.info("Running %s", command)
        try:
            subprocess.Popen(command)
        except Exception as err:
            log.error("Failed to launch %s: %s", command, err)
            InstallerUserMessage.basic_message(
                "Failed to launch %r, see log for details" % command[0])
            sys.exit(-1)
        else:
            # If we succeeded, terminate immediately so installer can replace
            # this running executable.
            sys.exit()

    else:                               # any platform other than Windows
        # In this case os.execv() should actually replace this process, just
        # as we want.
        if sys.platform.startswith('darwin'):
            # we can't just exec the .app
            exec_args = ['/usr/bin/open', next_executable]

        else:
            exec_args = [next_executable]

        log.info("Executing %s", exec_args)

        # ensure that logs are closed and flushed before execing
        logging.shutdown()
        try:
            os.execv(exec_args[0], exec_args)
            # if that worked, we're gone...

        except Exception as err:
            # logging is gone, can't do that, so put up a dialog
            message = "Failed to launch %r\n%s" % (exec_args, err)
            InstallerUserMessage.basic_message(message)
            sys.exit(-1)
        # process has been replaced or killed - does not return

if __name__ == "__main__":
    # Initialize the python logging system to SL Logging format and destination
    cgitb.enable(format='text')
    log = SL_Logging.getLogger('SL_Launcher')
    try:
        main()
    except Exception:
        log_traceback = cgitb.Hook(file=SL_Logging.stream(prefix_msg="Unhandled exception:"), format='text')
        log_traceback.handle()


    
