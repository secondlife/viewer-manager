#!/usr/bin/env python
 
"""\
$LicenseInfo:firstyear=2006&license=viewerlgpl$
Second Life Viewer Source Code
Copyright (C) 2006-2014, Linden Research, Inc.

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation;
version 2.1 of the License only.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA

Linden Research, Inc., 945 Battery Street, San Francisco, CA  94111  USA
$/LicenseInfo$
"""

"""
@file   SL_Launcher
@author coyot
@date   2016-06-23
"""

import cgitb
import os
import os.path
import sys
import collections
import download_update
import InstallerUserMessage
#NOTA BENE: 
#   For POSIX platforms, llsd.py will be imported from the same directory.  
#   For Windows, llsd.py will be compiled into the executable by pyinstaller
try:
   from llbase import llsd
except:
   #if Windows, this is expected, if not, we're dead
   if os.name == 'nt':
      pass
import platform
import subprocess
import update_manager

from datetime import datetime

#module globals
log_file_handle = None
#this is mostly for testing on Windows, emulating exe enviroment with $python scriptname
if 'ython' in sys.executable:
   sys.executable =  os.path.abspath(sys.argv[0])
cwd = os.path.dirname(os.path.realpath(str(sys.executable)))
python266 = os.path.join(cwd,"python26")
#make sure we find our local llbase
sys.path.insert(0, os.path.join(cwd, 'llbase'))
#python 2.6.6 is missing a few things we need
try:
   import argparse
except:
   sys.path.append(python266)
   import argparse
try:
   import Tkinter
except:
   sys.path.append(python266)
   import Tkinter
finally:
   #older versions of do not have XView and ttk needs it
   #just importing would pass the try, but with the wrong version
   if 'XView' not in dir(Tkinter):
      sys.path.insert(0, python266)
      import Tkinter
try:
   import ttk
except:
   sys.path.append(python266)
   import ttk

#this is to support pyinstaller, which uses sys._MEIPASS to point to the location
#the bootloader unpacked the bundle to.  If the getattr returns false, we are in a 
#normal Python environment.
if getattr(sys, 'frozen', False):
   __file__ = sys._MEIPASS

def silent_write(log_file_handle, text):
   #if we have a log file, write.  If not, do nothing.
   #this is so we don't have to keep trapping for an exception with a None handle
   #oh and because it is best effort, it is also a holey_write ;)
   if (log_file_handle):
      #prepend text for easy grepping
      timestamp = datetime.utcnow().strftime("%m/%d/%Y %H:%M:%S")
      log_file_handle.write(timestamp + " LAUNCHER: " + text + "\n")
  
def get_cmd_line(cmd_settings_file = None):
   if cmd_settings_file is None:
      platform_name = platform.system()
      #find the parent of the logs and user_settings directories
      if (platform_name == 'Darwin'):
         cmd_settings_file = os.path.join(os.path.dirname(os.path.dirname(os.path.realpath(__file__))), 'Resources/app_settings/cmd_line.xml')
      elif (platform_name == 'Linux'): 
         cmd_settings_file = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'app_settings/cmd_line.xml')
      #using list format of join is important here because the Windows pathsep in a string escapes the next char
      elif (platform_name == 'Windows'):
         cmd_settings_file = os.path.join(os.path.dirname(os.path.realpath(sys.executable)), 'app_settings', 'cmd_line.xml')
      else:
         cmd_settings_file = None
      
   try:
      cmd_line = llsd.parse((open(cmd_settings_file)).read())
   except:
      silent_write(log_file_handle, "Could not parse settings file %s" % cmd_settings_file)
      cmd_line = None
   
   return cmd_line

def capture_vmp_args(arg_list = None, cmd_line = None):
   #expected input format: arg_list = ['--set', 'foo', 'bar', '-X', '-Y', 'qux']
   #take a copy of the viewer parameters that are of interest to VMP.
   #the regex for a parameter is --<param> {opt1} {opt2}
   cli_overrides = {}   
   if not cmd_line:
      cmd_line = get_cmd_line()
   
   vmp_params = {'--channel':'channel', '--settings':'settings', '--update-service':'update-service', '--set':'set'}
   #the settings set with --set.  All such settings have only one argument.
   vmp_setters = ('UpdaterMaximumBandwidth', 'UpdaterServiceCheckPeriod', 'UpdaterServicePath', 'UpdaterServiceSetting', 'UpdaterServiceURL', 'UpdaterWillingToTest')   
   
   #Here turn the list into a queue, popping off the left as we go. Note that deque() makes a copy by value, not by reference
   #Because of the complexity introduced by the uncertainty of how many options a parameter can take, this is far less complicated code than the more
   #pythonic (x,y) = <some generator> since we will sometimes have (x), sometimes (x,y) and sometimes (x,y,z)
   #also, because the pop is destructive, we prevent ourselves from iterating back over list elements that iterator methods would peek ahead at
   if arg_list is not None:
      vmp_queue = collections.deque(arg_list)
      cli_overrides[vmp_params['--set']] = {}
      while (len(vmp_queue)):
         param = vmp_queue.popleft()
         #if it is not one of ours, pop through args until we get to the next parameter
         if param in vmp_params.keys():
            if param == '--set':
               setting_name = vmp_queue.popleft()
               setting_value = vmp_queue.popleft()
               if setting_name in vmp_setters:
                  cli_overrides[vmp_params[param]].update({setting_name:setting_value})
            else:
               #find out how many args this parameter has
               no_dashes = vmp_params[param]
               count = cmd_line[no_dashes]['count']
               param_args = []
               if count > 0:
                  for argh in range(0,count):
                     param_args.append(vmp_queue.popleft())
               #the parameter name is the key, the (possibly empty) list of args is the value
               cli_overrides[vmp_params[param]] = param_args
            
   #to prevent KeyErrors on missing keys, set the remainder to None
   try:
      cli_overrides['set']
   except KeyError:
      cli_overrides['set'] = {}
   for key in vmp_params:
      if key != '--set':
         try:
            cli_overrides[vmp_params[key]]
         except KeyError:
            cli_overrides[vmp_params[key]] = None
      else:
         for arg in vmp_setters:
            try:
               cli_overrides[vmp_params[key]][arg]
            except KeyError:
               cli_overrides[vmp_params[key]][arg] = None
   return cli_overrides
   
if __name__ == "__main__":
   #main entry point      
   #this and a few other update manager methods really should be refactored into a util lib
   parent_dir = update_manager.get_parent_path(update_manager.get_platform_key())
   cgitb.enable(logdir=os.path.join(parent_dir, "logs"), format='text')
   log_file_handle = update_manager.get_log_file_handle(parent_dir, 'launcher.log')
   silent_write(log_file_handle, "Found parent dir %s" % repr(parent_dir))
   
   executable_name = ""
   if sys.platform.startswith('darwin'):
      executable_name = "Second Life"
   elif sys.platform.startswith("win") or sys.platform.startswith("cyg"):
      #MAINT-7292: do not infer name from directory, instead read it from summary.json as produced by the build
      filename = update_manager.get_summary('win')['Executable']
      if os.path.isfile(os.path.join(cwd, filename)):
         executable_name = filename
      else:
         sys.exit("Can't find Windows viewer binary")
   elif sys.platform.startswith("linux"):
      executable_name = "secondlife"
   else:
      #SL doesn't run on VMS or punch cards
      sys.exit("Unsupported platform")
      
   #find the viewer to be lauched
   viewer_binary = os.path.join(os.path.dirname(os.path.abspath(sys.argv[0])), executable_name) 
   
   parser = argparse.ArgumentParser()
   args = parser.parse_known_args(sys.argv)
   #args[1] looks like ['./SL_Launcher', '--set', 'foo', 'bar', '-X', '-Y', 'qux'], dump the progname
   args_list_to_pass = args[1][1:]
   vmp_args = capture_vmp_args(args_list_to_pass)
   #make a copy by value, not by reference
   command = list(args_list_to_pass)
   
   silent_write(log_file_handle, "Calling update manager with %s" % repr(vmp_args))
   (success, state, condition) = update_manager.update_manager(vmp_args)
   silent_write(log_file_handle, "Update manager returned %s %s %s" % (success, state, condition))
   if sys.platform.startswith('darwin') and isinstance(condition, basestring):
      condition = os.path.join(condition,'Contents/MacOS/SL_Launcher')
   # From update_manager:
   #  (False, 'setup', None): error occurred before we knew what the update was (e.g., in setup or parsing)
   #  (False, 'download', version): we failed to download the new version
   #  (False, 'apply', version): we failed to apply the new version
   #  (True, None, None): No update found
   #  (True, 'in place', True): update applied in place
   #  (True, 'in place', path_to_new_launcher): Update applied by a new install to a new location
   #  (True, 'background', popen_object): background download initiated, object passed to wait on
   #  (True, 'skip', True): User has chosen to skip this optional update
   #These boil down three cases:
   #  Success is False, then pop up a message and launch the current viewer
   #  No update, update skipped, succeeded in place in foreground, or background update started: silently launch the current viewer channel
   #  Updated succeed to a different channel, launch that viewer and wait
   if not success:
      msg = 'Update failed in the %s process.  Please check logs.  Viewer will launch starting momentarily.' % state
      update_manager.after_frame(msg)
      command.insert(0,viewer_binary)
      viewer_process = subprocess.Popen(command)
      silent_write(log_file_handle, "Viewer successfully launched after failure to get a valid update response.")
      #at the moment, we just wait here.  Later, the crash monitor will be launched at this point
      viewer_process.wait()
   elif (success == True and 
         (state == None 
          or (state == 'skip')
          or (state ==  'background')
          or (state == 'in place' and condition == True))):
      #update manager returns the argument dict to the downloader in the condition variable
      if success == True and state ==  'background' and type(condition) == 'dict':
         silent_write(log_file_handle, "Launching background downloader with %s" % repr(condition))
         download_update.download_update(**condition)
         silent_write(log_file_handle, "Background download complete")
      elif success == True and state ==  'background' and type(condition) != 'dict':
         silent_write(log_file_handle, "Received erroneous condition %s from update manager, launching old viewer" % repr(condition))      
      silent_write(log_file_handle, "Launching current channel viewer, no required upgrade found.")
      command.insert(0,viewer_binary)
      viewer_process = subprocess.Popen(command)
      silent_write(log_file_handle, "Viewer successfully launched after launching background downloader.")
      #at the moment, we just wait here.  Later, the crash monitor will be launched at this point
      viewer_process.wait()
   else:
      #'condition' is the path to the new launcher.
      command.insert(0,condition)
      silent_write(log_file_handle, "Launching new channel viewer: %s." % command)
      try:
         viewer_process = subprocess.Popen(command)
         silent_write(log_file_handle, "Newly updated viewer successfully launched.")
         #at the moment, we just wait here.  Later, the crash monitor will be launched at this point
         viewer_process.wait()
      except Exception as e:
         #if another viewer is running or windows install is in progress, subprocess will throw an unhandlable exception
         silent_write(log_file_handle, "Exception spawning new viewer: %s" % repr(e))
         
   silent_write(log_file_handle, "Launcher exiting after viewer exit.")
